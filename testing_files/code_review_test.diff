diff --git a/src/auth/user_service.py b/src/auth/user_service.py
index 1234567..abcdefg 100644
--- a/src/auth/user_service.py
+++ b/src/auth/user_service.py
@@ -1,15 +1,35 @@
 import sqlite3
+import hashlib
+import secrets
+import logging
 from typing import Optional, Dict
+from datetime import datetime, timedelta
+
+logger = logging.getLogger(__name__)
 
 class UserService:
     def __init__(self):
-        self.db = sqlite3.connect('users.db')
+        self.db_path = 'users.db'
+        self.session_timeout = timedelta(hours=24)
     
-    def create_user(self, username: str, password: str):
+    def create_user(self, username: str, password: str) -> Dict[str, str]:
+        """Create a new user with secure password hashing"""
+        if len(password) < 8:
+            raise ValueError("Password must be at least 8 characters long")
+        
+        # Generate salt and hash password securely
+        salt = secrets.token_hex(16)
+        password_hash = hashlib.pbkdf2_hmac('sha256', password.encode(), salt.encode(), 100000)
+        
+        with sqlite3.connect(self.db_path) as conn:
+            cursor = conn.cursor()
+            try:
+                # Use parameterized query to prevent SQL injection
+                cursor.execute(
+                    "INSERT INTO users (username, password_hash, salt, created_at) VALUES (?, ?, ?, ?)",
+                    (username, password_hash.hex(), salt, datetime.now().isoformat())
+                )
+                conn.commit()
+                logger.info(f"User {username} created successfully")
+                return {"status": "success", "user_id": cursor.lastrowid}
+            except sqlite3.IntegrityError:
+                raise ValueError("Username already exists")
+    
+    def authenticate_user(self, username: str, password: str) -> Optional[Dict]:
+        """Authenticate user with secure password verification"""
+        with sqlite3.connect(self.db_path) as conn:
+            cursor = conn.cursor()
+            cursor.execute(
+                "SELECT id, password_hash, salt FROM users WHERE username = ?", 
+                (username,)
+            )
+            result = cursor.fetchone()
+            
+            if result:
+                user_id, stored_hash, salt = result
+                # Verify password using the same hashing method
+                password_hash = hashlib.pbkdf2_hmac('sha256', password.encode(), salt.encode(), 100000)
+                
+                if password_hash.hex() == stored_hash:
+                    # Update last login
+                    cursor.execute(
+                        "UPDATE users SET last_login = ? WHERE id = ?",
+                        (datetime.now().isoformat(), user_id)
+                    )
+                    conn.commit()
+                    return {
+                        "user_id": user_id,
+                        "username": username,
+                        "authenticated": True
+                    }
+            
+            return None
+    
+    def get_user_by_id(self, user_id: int) -> Optional[Dict]:
+        """Get user information by ID"""
         try:
-            cursor = self.db.cursor()
-            cursor.execute(f"INSERT INTO users (username, password) VALUES ('{username}', '{password}')")
-            self.db.commit()
-            return {"status": "success"}
+            with sqlite3.connect(self.db_path) as conn:
+                cursor = conn.cursor()
+                cursor.execute(
+                    "SELECT id, username, created_at, last_login FROM users WHERE id = ?",
+                    (user_id,)
+                )
+                result = cursor.fetchone()
+                
+                if result:
+                    return {
+                        "id": result[0],
+                        "username": result[1], 
+                        "created_at": result[2],
+                        "last_login": result[3]
+                    }
+                return None
         except Exception as e:
-            return {"status": "error", "message": str(e)}
+            logger.error(f"Error fetching user {user_id}: {str(e)}")
+            raise
